{"version":3,"file":"injected.js","sources":["../extension/injected.ts"],"sourcesContent":["// Injected script that runs in the page context to intercept fetch calls\n\ninterface TokenHeaders {\n  inputTokens: number;\n  outputTokens: number;\n  cacheCreationTokens?: number;\n  cacheReadTokens?: number;\n}\n\ninterface CapturedData {\n  url: string;\n  method: string;\n  status: number;\n  tokens?: TokenHeaders;\n  model?: string;\n  conversationId?: string;\n  messagePreview?: string;\n  fullContent?: string;\n  userMessage?: string;\n  timestamp: number;\n}\n\nconst originalFetch = window.fetch;\n\nwindow.fetch = async function (\n  input: RequestInfo | URL,\n  init?: RequestInit\n): Promise<Response> {\n  const response = await originalFetch.call(this, input, init);\n\n  try {\n    const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;\n\n    // Only intercept claude.ai API calls\n    if (url.includes('claude.ai/api/')) {\n      const tokens = extractTokenHeaders(response.headers);\n      const model = response.headers.get('x-model') ?? undefined;\n\n      // Extract conversation ID from URL (handles both /chat_conversations/ and /conversations/)\n      const conversationMatch = url.match(/\\/(?:chat_)?conversations\\/([a-f0-9-]+)/);\n      const conversationId = conversationMatch?.[1];\n\n      // For completion endpoints, capture the response body\n      if (url.includes('/completion') && init?.method === 'POST') {\n        // Clone the response so we can read it without affecting the original\n        const clonedResponse = response.clone();\n\n        // Try to extract model and user message from request body\n        let requestModel: string | undefined;\n        let userMessage: string | undefined;\n        if (init?.body) {\n          try {\n            const bodyStr = typeof init.body === 'string' ? init.body : new TextDecoder().decode(init.body as ArrayBuffer);\n            const bodyJson = JSON.parse(bodyStr);\n            requestModel = bodyJson.model;\n\n            // Extract the user's message - usually the last user message in the prompt\n            if (bodyJson.prompt) {\n              // Legacy format: prompt is a string\n              userMessage = bodyJson.prompt;\n            } else if (bodyJson.messages && Array.isArray(bodyJson.messages)) {\n              // Find the last user message\n              const userMessages = bodyJson.messages.filter((m: { role: string }) => m.role === 'user');\n              const lastUserMsg = userMessages[userMessages.length - 1];\n              if (lastUserMsg) {\n                if (typeof lastUserMsg.content === 'string') {\n                  userMessage = lastUserMsg.content;\n                } else if (Array.isArray(lastUserMsg.content)) {\n                  // Content might be an array of text blocks\n                  userMessage = lastUserMsg.content\n                    .filter((c: { type: string }) => c.type === 'text')\n                    .map((c: { text: string }) => c.text)\n                    .join('\\n');\n                }\n              }\n            }\n          } catch {\n            // Ignore parse errors\n          }\n        }\n\n        // Process the streaming response in the background\n        processStreamingResponse(clonedResponse, {\n          url,\n          method: init?.method ?? 'POST',\n          status: response.status,\n          tokens: tokens ?? undefined,\n          model: model || requestModel,\n          conversationId,\n          userMessage,\n          timestamp: Date.now(),\n        });\n      } else {\n        // For non-completion requests, just log basic info\n        const capturedData: CapturedData = {\n          url,\n          method: init?.method ?? 'GET',\n          status: response.status,\n          tokens: tokens ?? undefined,\n          model,\n          conversationId,\n          timestamp: Date.now(),\n        };\n\n        console.log('[Claude Utils] Captured API call:', url, capturedData);\n\n        // Dispatch custom event for content script to pick up\n        window.dispatchEvent(\n          new CustomEvent('claude-utils-response', {\n            detail: capturedData,\n          })\n        );\n      }\n    }\n  } catch (e) {\n    // Silently ignore errors to not break the page\n    console.error('[Claude Utils] Error intercepting fetch:', e);\n  }\n\n  return response;\n};\n\nasync function processStreamingResponse(\n  response: Response,\n  baseData: CapturedData\n): Promise<void> {\n  try {\n    const reader = response.body?.getReader();\n    if (!reader) {\n      window.dispatchEvent(\n        new CustomEvent('claude-utils-response', { detail: baseData })\n      );\n      return;\n    }\n\n    const decoder = new TextDecoder();\n    let fullText = '';\n    let extractedTokens: TokenHeaders | undefined;\n    let extractedModel: string | undefined;\n    let inputTokens = 0;\n    let outputTokens = 0;\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      const chunk = decoder.decode(value, { stream: true });\n      fullText += chunk;\n    }\n\n    // Parse the SSE stream to extract message content and token info\n    const lines = fullText.split('\\n');\n    let messageContent = '';\n\n    for (const line of lines) {\n      if (line.startsWith('data: ')) {\n        try {\n          const data = JSON.parse(line.slice(6));\n\n          // Extract message content from different event types\n          if (data.type === 'content_block_delta' && data.delta?.text) {\n            messageContent += data.delta.text;\n          }\n\n          // Extract completion message (legacy format)\n          if (data.completion) {\n            messageContent = data.completion;\n          }\n\n          // message_start contains model and input tokens\n          if (data.type === 'message_start' && data.message) {\n            // Claude.ai sometimes sends empty string for model\n            if (data.message.model && data.message.model.length > 0) {\n              extractedModel = data.message.model;\n            }\n            if (data.message.usage?.input_tokens) {\n              inputTokens = data.message.usage.input_tokens;\n            }\n          }\n\n          // message_delta contains output tokens\n          if (data.type === 'message_delta' && data.usage?.output_tokens) {\n            outputTokens = data.usage.output_tokens;\n          }\n\n          // Some responses include usage at the top level\n          if (data.usage) {\n            if (data.usage.input_tokens) inputTokens = data.usage.input_tokens;\n            if (data.usage.output_tokens) outputTokens = data.usage.output_tokens;\n          }\n\n          // Extract model from various places\n          if (data.model && !extractedModel) {\n            extractedModel = data.model;\n          }\n        } catch {\n          // Not valid JSON, skip\n        }\n      }\n    }\n\n    // Build token object if we found any tokens\n    if (inputTokens > 0 || outputTokens > 0) {\n      extractedTokens = { inputTokens, outputTokens };\n    }\n\n    // Create preview (first 200 chars)\n    const messagePreview = messageContent.slice(0, 200) + (messageContent.length > 200 ? '...' : '');\n\n    const capturedData: CapturedData = {\n      ...baseData,\n      tokens: extractedTokens ?? baseData.tokens,\n      model: extractedModel ?? baseData.model,\n      messagePreview: messagePreview || undefined,\n      fullContent: messageContent || undefined,\n      userMessage: baseData.userMessage,\n    };\n\n    console.log('[Claude Utils] Captured completion:', capturedData.model, {\n      userMsgLen: baseData.userMessage?.length ?? 0,\n      responseMsgLen: messageContent.length,\n    });\n\n    // Dispatch event with full data\n    window.dispatchEvent(\n      new CustomEvent('claude-utils-response', {\n        detail: capturedData,\n      })\n    );\n  } catch (e) {\n    console.error('[Claude Utils] Error processing streaming response:', e);\n\n    // Still dispatch the basic data even if we couldn't parse the body\n    window.dispatchEvent(\n      new CustomEvent('claude-utils-response', {\n        detail: baseData,\n      })\n    );\n  }\n}\n\nfunction extractTokenHeaders(headers: Headers): TokenHeaders | null {\n  const inputTokens = headers.get('anthropic-input-tokens');\n  const outputTokens = headers.get('anthropic-output-tokens');\n\n  if (!inputTokens || !outputTokens) {\n    return null;\n  }\n\n  const result: TokenHeaders = {\n    inputTokens: parseInt(inputTokens, 10),\n    outputTokens: parseInt(outputTokens, 10),\n  };\n\n  const cacheCreation = headers.get('anthropic-cache-creation-input-tokens');\n  const cacheRead = headers.get('anthropic-cache-read-input-tokens');\n\n  if (cacheCreation) {\n    result.cacheCreationTokens = parseInt(cacheCreation, 10);\n  }\n\n  if (cacheRead) {\n    result.cacheReadTokens = parseInt(cacheRead, 10);\n  }\n\n  return result;\n}\n\n// Signal that the script is loaded\nconsole.log('[Claude Utils] Fetch interceptor loaded');\n"],"names":[],"mappings":"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"}